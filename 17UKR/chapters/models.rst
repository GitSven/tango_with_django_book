.. _model-label:

Моделі і бази даних
===================
Працюючи з базами даних, доводиться часто бруднити руки колупанням у SQL. У Django більшу частину цієї марудної роботи виконують функції *об'єктно-реляційного відображення (ORM)* та те, як Django приховує таблиці бази даних через моделі. По суті, модель це об'єкт Python що описує вашу модель (таблицю) даних. Замість безпосередньої роботи з таблицями бази даних з використанням SQL все, що вам потрібно робити це орудувати об'єктом Python. В цій главі ми розглянемо як налаштувати базу даних і моделі потрібні для Rango.

Потреби Rango
-------------
По перше, розглянемо потреби Rango у даних. У наступному переліку наведено ключові потреби Rango:

* Rango це *каталог веб-сторінок*, тобто сайт з посиланнями на інші сторінки. 
* Маємо певну кількість *категорій веб-сторінок* і кожна категорія має деяку кількість посилань. У розділі :ref:`overview-label` ми вирішили, що це зв'язок один-до-багатьох. Подивіться діаграму зв'язків сутностей.
* Категорія має ім'я, кількість відвідувань та кількість зв'язків.
* Сторінка посилається на категорію, має назву, URL та кількість відвідувань.

.. figure:: ../images/rango-erd.svg
	:scale: 100%
	:figclass: align-center

	Діаграма зв'язків двох головних сутностей Rango.

Розповімо Django про базу даних
-------------------------------
До створення будь яких моделей потрібно налаштувати базу даних. В версії Django 1.7, коли створюється проект, Django автоматично створює словник на ім'я ``DATABASES`` у файлі ``settings.py``. Він містить щось на кшталт:

.. code-block:: python
	
	DATABASES = {
	    'default': {
	        'ENGINE': 'django.db.backends.sqlite3',
	        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
	    }
	}


	

Як видно, за замовчуванням, буде використовуватися сервер SQLite3. Завдяки цьому ми отримуємо доступ до легкої пітонівскої бази даних, `SQLite <http://www.sqlite.org/>`_, котра чудово  пасує для  розробки. 
Єдине значення яке треба встановити - це ``NAME`` у парі ключ/значення, котре повинне вказувати на файл бази даних. Для інших баз даних до словника можна додати такі ключі як ``USER``, ``PASSWORD``, ``HOST`` та ``PORT``.

.. note:: Для посібника достатньо SQLite, але для розгортання додатку, можливо, потрібен кращий варіант. Краще використовувати більш потужний та масштабований сервер. Django постачається з підтримкою кількох поширених серверів баз даних, таких як `PostgreSQL <http://www.postgresql.org/>`_ і `MySQL <http://www.mysql.com/>`_. Подивіться `офіційну документацію з Django про сервери баз даних <https://docs.djangoproject.com/en/1.7/ref/settings/#std:setting-DATABASE-ENGINE>`_. Також, можна прочитати `цю чудову статтю <http://www.sqlite.org/whentouse.html>`_ на сайті SQLite в котрій розглядаються випадки коли краще використовувати легкий сервер SQLite, а коли ні.

Створення моделей
-----------------
Зі сконфігурованою базою у ``settings.py``, давайте створимо дві моделі даних для додатку Rango.

В ``rango/models.py`` ми визначимо два класи - обидва повинні бути успадковані від ``django.db.models.Model``. Ці два класи Python будуть визначеннями моделей що уособлюють *категорії* і *сторінки*. Визначимо моделі ``Category`` і ``Page`` як показано нижче.

.. code-block:: python
	
	class Category(models.Model):
	    name = models.CharField(max_length=128, unique=True)

	    def __unicode__(self):  #For Python 2, use __str__ on Python 3
	        return self.name
	
	class Page(models.Model):
	    category = models.ForeignKey(Category)
	    title = models.CharField(max_length=128)
	    url = models.URLField()
	    views = models.IntegerField(default=0)
	    
	    def __unicode__(self):	#For Python 2, use __str__ on Python 3
	        return self.title

При визначенні моделі потрібно вказати перелік атрибутів та пов'язаних з ними типів разом з необов'язковими параметрами. Django має багато вбудованих полів. Найбільш розповсюджені перераховано далі.

* ``CharField``, поле для зберігання символьних даних (наприклад - рядки). Вкажіть ``max_length`` щоб задати максимальну кількість символів що будуть зберігатися в полі.
* ``URLField``, як ``CharField``, але призначене для зберігання рядків URL-ів. Так само можна задати параметр ``max_length``.
* ``IntegerField``, для зберігання цілих чисел.
* ``DateField``, у цьому полі зберігається Python-івський тип  ``datetime.date``.

Повний перелік можна подивитися в `документації Django <https://docs.djangoproject.com/en/1.7/ref/models/fields/>`_ .

Для кожного поля можна задати параметр ``unique``. Якщо встановити в ``True`` то в базі буде можливо зберігати тільки унікальні значення цього поля. Наприклад, подивимось на нашу модель ``Category``. Поле ``name`` має встановлений параметр ``unique`` - тобто кожна категорія має бути унікальною.

Це корисно коли потрібно якесь певне поле використовувати в якості додаткового ключа. Так само, для кожного поля, можна додатково задати такі параметри як значення за замовчуванням (``default='value'``), або дозволити полю приймати значення ``NULL`` (``null=True``) чи заборонити. 

Django також надає простий механізм, що дозволяє пов'язувати таблиці моделей бази даних. Цей механізм вбудований в три, перелічені далі, поля.

* ``ForeignKey``, цей тип поля дозволяє створювати зв'язки один-до-багатьох;
* ``OneToOneField``, один-до-одного;
* ``ManyToManyField``, та багато-до-багатьох.

В наведеному вище прикладі поле ``category`` моделі ``Page`` має тип ``ForeignKey``. Це дозволяє створити зв'язок один-до-багатьох з моделлю (таблицею) ``Category``, котра передається як аргумент конструктору поля. *Треба усвідомити, що Django створює для таблиць моделей поле ID автоматично. Отже, нема необхідності створювати первинний ключ для моделей - це вже зроблено!*

.. note:: При створенні моделей Django рекомендуємо додавати метод ``__unicode__()``  - цей метод майже такий самий як ``__str__()``. Якщо вам не знайомі ці методи, то вважайте їх аналогічними методу ``toString()`` класів Java. Отже, метод ``__unicode__()`` використовується для відображення моделі в читабельний рядок unicode. Наша модель ``Category``, наприклад, в методі ``__unicode__()`` повертає ім'я категорії - те, що однозначно визначає категорію і це використовується в інтерфейсі адміністратора, що буде показано далі в цьому розділі.
	
	Додавати метод ``__unicode__()`` корисно також і для зневадження. Виконавши ``print`` на екземплярі моделі ``Category`` *без* метода ``__unicode__()`` ви отримаєте ``<Category: Category object>``. Ми знаємо що це категорія, але *котра?*. Якщо додати ``__unicode__()`` отримаємо ``<Category: python>``, де ``python`` це ``name`` переданої категорії. Значно краще!

Створення та міграція бази даних
--------------------------------
Після визначення моделей, ми можемо дати попрацювати магії Django, та створити таблиці в базі даних. В попередніх версіях Django для цього потрібно виконати команду:

``$ python manage.py syncdb``

Django 1.7 надає знаряддя міграції для керування базою даних та відображення в ній змін моделей. Так що процес став трохи складнішим - але задум полягає в тому, щоб при зміні в моделях мати можливість оновити базу даних не видаляючи її.

Налаштування бази даних та створення суперкористувача
.....................................................
По-перше, потрібно ініціювати базу даних. Це робиться за допомогою команди migrate.


::


	$ python manage.py migrate


	Operations to perform:
	  Apply all migrations: admin, contenttypes, auth, sessions
	Running migrations:
	  Applying contenttypes.0001_initial... OK
	  Applying auth.0001_initial... OK
	  Applying admin.0001_initial... OK
	  Applying sessions.0001_initial... OK
	  
	  
Як ви пам'ятаєте, у файлі ``settings.py`` є список INSTALLED_APPS (встановлені додатки). Цей початковий виклик migrate створює таблиці для пов'язаних додатків, наприклад auth, admin, і таке інше.

Тепер потрібно створити суперкористувача для обслуговування бази даних. Запустіть таку команду:

::


	$ python manage.py createsuperuser

Обліковий запис суперкористувача буде використовуватись для доступу до інтерфейсу адміністратора. Введіть ім'я користувача, адресу e-mail та пароль.  Далі, скрипт повинен успішно завершитися. Переконайтеся, що ви записали ім'я користувача і пароль.

Створення / Оновлення моделей / Таблиці
.......................................

Після внесення змін до моделей потрібно зареєструвати ці зміни, для потрібного додатку, за допомогою команди ``makemigrations``. Так, для *rango* потрібно виконати:

::
	
	$ python manage.py makemigrations rango
	
	Migrations for 'rango':
	  0001_initial.py:
	    - Create model Category
	    - Create model Page

Якщо переглянути каталог ``rango/migrations``, ви побачите, що створено пітонівський скрипт на ім'я ``0001_initial.py`` . Щоб подивитись SQL, який буде виконано щоб зробити цю міграцію, можна виконати команду ``python manage.py sqlmigrate <app_name> <migration_no>``. Номер показаної раніше міграції 0001, тобто ми повинні виконати команду ``python manage.py sqlmigrate rango 0001`` щоб подивитись SQL для *rango*. Спробуйте це зробити.

Тепер, щоб застосувати міграції (по суті - створити таблиці бази даних), потрібно запустити:


::
	
	
	$ python manage.py migrate

	Operations to perform:
	  Apply all migrations: admin, rango, contenttypes, auth, sessions
	Running migrations:
	  Applying rango.0001_initial... OK
	  
	  
	  

.. warning:: Кожного разу коли ви доповнюєте сущі моделі *потрібно повторювати ці кроки* ``python manage.py makemigrations <app_name>``, і потім ``python manage.py migrate``
	
Можливо ви звернули увагу, що модель ``Category`` поки що не має деяких полів, котрі ми описали у вимогах до додатку Rango. Згодом ми додамо ці поля, щоб нагадати процес оновлення.


Моделі Django і оболонка Django
-------------------------------
Перед вивченням адміністративного інтерфейсу Django, варто зауважити що є можливість взаємодії з моделями Django за допомогою оболонки Django - дуже корисного засобу для зневадження. Ми покажемо як створити екземпляр ``Category`` за допомогою цього засобу.

Для доступу до оболонки потрібно з кореневого каталогу проекту запустити таку команду:

``$ python manage.py shell``

Запуститься інтерпретатор Python, та завантажаться налаштування проекту. Тепер можна взаємодіяти з моделями. Наведена далі термінальна сесія показує цю функціональність. Читайте коментарі щоб з'ясувати що робить кожна команда.

.. code-block:: python
	
	# Імпорт моделі Category додатку Rango
	>>> from rango.models import Category
	
	# Показ всіх поточних категорій
	>>> print Category.objects.all()
	[] # Поверне пустий список (бо ще не визначено жодної категорії!)
	
	# Створюємо нову категорію та зберігаємо до бази даних.
	>>> c = Category(name="Test")
	>>> c.save()
	
	# Тепер ще раз подивимось перелік категорій.
	>>> print Category.objects.all()
	[<Category: test>] # Тепер у базі є категорія названа 'test'!
	
	# Вихід з оболонки Django.
	>>> quit()

В цьому прикладі ми, в першу чергу, імпортуємо модель з котрою збираємось орудувати. Потім друкуємо всі категорії, але жодної ще нема, таблиці бази ще порожні. Потім створюємо і зберігаємо Category, перед тим як роздрукувати їх знову. Друга спроба ``print`` повинна показати щойно додану ``Category``.

.. note:: Наведений приклад - лише базова проба можливостей роботи оболонки Django з базами даних. Якщо ви ще не зробили цього, зараз саме час опрацювати `офіційний посібник Django щоб дізнатися більше про взаємодію з моделями <https://docs.djangoproject.com/en/1.7/intro/tutorial01/>`_. Також подивіться ` перелік доступних команд для роботи з моделями в документації з Django <https://docs.djangoproject.com/en/1.7/ref/django-admin/#available-commands>`_ .

.. _admin-section:

Конфігурація інтерфейсу адміністратора
--------------------------------------
Однією з переваг Django є вбудований адміністративний веб-інтерфейс (далі за текстом - адмінка) що дозволяє переглядати та редагувати збережені дані моделей та відповідних таблиць. В файлі ``settings.py`` зверніть увагу на попередньо встановлений додаток ``django.contrib.admin``, а також на URL взірець в файлі проекту ``urls.py``, що узгоджується з ``admin/``.

Запустіть сервер розробки:

::


	$ python manage.py runserver
	
	
і відвідайте URL ``http://127.0.0.1:8000/admin/``. Для доступу до адмінки використайте створені для суперкористувача логін і пароль. Поки зміст адмінки обмежений - лише засоби адміністрування сайту: ``Groups`` (групи) і ``Users`` (користувачі). Отже, нам потрібно налаштувати Django щоб додати моделі з ``rango``.

 Для цього відкрийте файл ``rango/admin.py`` та додайте такий код:

.. code-block:: python
	
	from django.contrib import admin
	from rango.models import Category, Page

	admin.site.register(Category)
	admin.site.register(Page)
	
Це *зареєструє* моделі в адмінці. Якщо будуть ще моделі, треба лише додати виклик функції ``admin.site.register()``, передавши модель в якості параметра.

Після внесення змін, знову подивіться: ``http://127.0.0.1:8000/admin/``. Ви повинні побачити моделі Category та Page, як на малюнку :num:`fig-rango-admin`. 

.. _fig-rango-admin:

.. figure:: ../images/ch5-rango-admin-models.png
	:figclass: align-center

	Адмінка Django. Зверніть увагу на Rango та моделі.

Спробуйте клацнути посилання ``Categorys`` в секції ``Rango``. Ви повинні побачити категорію ``test`` створену за допомогою оболонки Django. Спробуйте видалити категорію, все одно, далі, ми будемо заповнювати базу за допомогою скрипту. Інтерфейс легкий у використанні. Приділіть кілька хвилин для створення, зміни і видалення категорій та сторінок. Також спробуйте додати користувачів з правами доступу до адмінки Django, додавши їх до ``User`` в додатку ``Auth``.

.. note:: В адмінці є друкарські помилки (categorys, а не categories). Це легко виправити, додавши вкладений клас ``Meta``  з атрибутом ``verbose_name_plural`` до визначення моделі. Для отримання подробиць перегляньте `документацію <https://docs.djangoproject.com/en/1.7/topics/db/models/#meta-options>`__ .

.. note:: Приклад файлу ``admin.py`` додатку Rango максимально спрощено. Є багато різноманітних засобів для ``admin.py`` щоб змінити вигляд адмінки. Для цього посібника ми використали лише кістяк адмінки, але, якщо цікаво, подивіться `документацію <https://docs.djangoproject.com/en/1.7/ref/contrib/admin/>`__ .

.. _model-population-script-label:

Створення скрипту наповнення
-----------------------------
То марудна справа - наповнювати базу тестовими даними. Багато розробників створює тестові дані наздогад лупцюючи клавіатуру, наче мавпа, що намагається написати Шекспіра. Якщо ви працюєте у невеличкій команді, тоді кожен має ввести якісь дані. Однак краще, ніж робити це незалежно, написати скрипту, щоб кожен мав однакові дані, корисні і придатні, ніж якийсь негідний шматок тестових даних. Таким чином, це хороша практика - створювати те що ми називаємо *скриптом наповнення* для бази даних. Цей скрипт розроблено для автоматичного наповнення бази даних тестовими даними.

Написання скрипту наповнення бази даних Rango, ми почнемо зі створення нового модуля Python у кореневому каталозі проекту (наприклад ``<workspace>/tango_with_django_project/``). Створіть файл ``populate_rango.py`` та додайте такий код:

.. code-block:: python
	
	import os
	os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'tango_with_django_project.settings')

	import django
	django.setup()

	from rango.models import Category, Page
	
	
	def populate():
	    python_cat = add_cat('Python')
	
	    add_page(cat=python_cat,
	        title="Official Python Tutorial",
	        url="http://docs.python.org/2/tutorial/")
	
	    add_page(cat=python_cat,
	        title="How to Think like a Computer Scientist",
	        url="http://www.greenteapress.com/thinkpython/")
	
	    add_page(cat=python_cat,
	        title="Learn Python in 10 Minutes",
	        url="http://www.korokithakis.net/tutorials/python/")
	
	    django_cat = add_cat("Django")
	
	    add_page(cat=django_cat,
	        title="Official Django Tutorial",
	        url="https://docs.djangoproject.com/en/1.5/intro/tutorial01/")
	
	    add_page(cat=django_cat,
	        title="Django Rocks",
	        url="http://www.djangorocks.com/")
	    
	    add_page(cat=django_cat,
	        title="How to Tango with Django",
	        url="http://www.tangowithdjango.com/")
	
	    frame_cat = add_cat("Other Frameworks")
	
	    add_page(cat=frame_cat,
	        title="Bottle",
	        url="http://bottlepy.org/docs/dev/")
	
	    add_page(cat=frame_cat,
	        title="Flask",
	        url="http://flask.pocoo.org")
	
	    # Print out what we have added to the user.
	    for c in Category.objects.all():
	        for p in Page.objects.filter(category=c):
	            print "- {0} - {1}".format(str(c), str(p))
	
	def add_page(cat, title, url, views=0):
	    p = Page.objects.get_or_create(category=cat, title=title)[0]
		p.url=url
		p.views=views
		p.save()
	    return p
	
	def add_cat(name):
	    c = Category.objects.get_or_create(name=name)[0]
	    return c
	
	# Start execution here!
	if __name__ == '__main__':
	    print "Starting Rango population script..."
	    populate()

Хоча скрипт й виглядає як купа коду, але те  що він робить відносно просте. На початку файлу визначено кілька функцій, виконання коду починається в кінці, знайдіть рядок ``if __name__ == '__main__'``. Ми запускаємо функцію ``populate()``.

.. warning:: Коли імпортуєте моделі Django, переконайтесь, що ви імпортували налаштування проекту шляхом імпорту django та встановили змінну оточення ``DJANGO_SETTINGS_MODULE``, так щоб вона вказувала на файл налаштувань проекту. Потім потрібно виконати ``django.setup()`` щоб імпортувати налаштування. Якщо цього не зробити - створиться виняток. Саме тому ми імпортуємо ``Category`` і ``Page`` після завантаження налаштувань.

Функція ``populate()`` відповідальна за виклики функцій ``add_cat()`` і ``add_page()``, котрі, в свою чергу, відповідні за створення нових категорій та сторінок. Наприкінці, в циклі переглядаються моделі ``Category`` і ``Page`` щоб роздрукувати всі екземпляри ``Page`` та відповідні їм категорії.

.. note:: Ми користуємось методом ``get_or_create()`` (отримай_або_створи) для створення екземплярів моделей. Нам не потрібні двійники, тому ми використовуємо ``get_or_create()`` котрий перевіряє чи є такий екземпляр в базі. Якщо нема, цей метод створить його. Вбудований метод звільняє нас від написання та тестування купи коду. Як ми вже згадували раніше, навіщо винаходити колесо, якщо воно вже є?
	
	Метод ``get_or_create()`` повертає кортеж ``(object, created)``. Перший елемент ``object`` - це посилання на екземпляр моделі, нової якщо не було знайдено в базі, або відповідної моделі з бази. Екземпляр створюється з параметрів що передаються методу - в нашому випадку ``category``, ``title``, ``url`` і ``views``. Якщо ``created`` це ``true`` - метод ``get_or_create()`` створив новий екземпляр моделі.
	
	``[0]`` в кінці виклику метода - для того щоб отримати ``object`` з кортежу що повертає ``get_or_create()``. Як у більшості мов програмування, пітонівські кортежі використовують `нумерацію від нуля <http://en.wikipedia.org/wiki/Zero-based_numbering>`_.
	
	Перегляньте `документацію Django <https://docs.djangoproject.com/en/1.7/ref/models/querysets/#get-or-create>`_ з методу ``get_or_create()``.

Зберігаємо скрипт, змінюємо шлях у терміналі на каталог нашого проекту і запускаємо на виконання командою ``$ python populate_rango.py``. Результат повинен бути як показано нижче.

::
	
	$ python populate_rango.py
	
	Starting Rango population script...
	- Python - Official Python Tutorial
	- Python - How to Think like a Computer Scientist
	- Python - Learn Python in 10 Minutes
	- Django - Official Django Tutorial
	- Django - Django Rocks
	- Django - How to Tango with Django
	- Other Frameworks - Bottle
	- Other Frameworks - Flask

Тепер давайте подивимось чи наповнилась база даних.Перезапустіть сервер розробки Django, перейдіть до адмінки, і перегляньте які ви маєте категорії і сторінки. Чи бачите ви всі сторінки (якщо клацнути на ``Pages``), як на малюнку :num:`fig-admin-populated`?

.. _fig-admin-populated:

.. figure:: ../images/ch5-rango-admin.png
	:figclass: align-center

	Адмінка Django, що показує таблицю Page, наповнену тестовими даними зі скрипту наповнення.

Написання скрипту наповнення потребує трохи часу, але при роботі в команді кожен має можливість отримати скрипт наповнення з тестовими даними. Також це корисно при тестуванні.

Підсумок
--------
Тепер, після ознайомлення з основними принципами роботи з моделями, саме час підсумувати залучені процеси. Ми розділили основні задачі на кілька частин.

Налаштування бази даних
.......................
Спочатку потрібно розповісти Django про базу даних котру ви збираєтесь використовувати (тобто сконфігурувати ``DATABASES`` в settings.py). Також можна зареєструвати потрібні моделі в файлі ``admin.py`` щоб зробити їх доступними через адмінку.

Додавання моделі
................
Процес додавання моделей можна розбити на п'ять кроків.

#. По-перше, створіть нову модель(лі) в файлі додатку Django ``models.py``.
#. Оновіть ``admin.py`` щоб додати та зареєструвати нову модель(лі).
#. Після - створіть міграцію ``$ python manage.py makemigrations``
#. Застосуйте зміни ``$ python manage.py migrate``. Це створить необхідну для моделі(ей) інфраструктуру в базі даних.
#. Створіть/Відредагуйте скрипт наповнення для нових моделей.

Постійно трапляються випадки коли виникає потреба видалити базу даних. В такому разі запустіть команду ``migrate``, потім команду ``createsuperuser``, за нею команди ``sqlmigrate`` для кожного додатку, нарешті можна наповнювати базу даних.

Вправи
------
По завершенню розділу, спробуйте виконати ці вправи щоб закріпити знання та набути практики.

* До моделі Category додайте атрибути ``views`` (кількість переглядів) і ``likes`` (кількість уподобань - лайків) з усталеним значенням нуль.
* Створіть міграції, та застосуйте їх до бази даних
* Скоригуйте скрипт наповнення так щоб категорія Python мала 128 переглядів і 64 лайки, категорія Django 64 перегляди і 32 лайки, а категорія Other Frameworks мала 32 перегляди і 16 лайків.
* Вивчіть `другу частину офіційного посібника Django <https://docs.djangoproject.com/en/1.7/intro/tutorial02/>`_ . Це допоможе підсилити вивчене а також ви дізнаєтесь більше про адмінку.
* Змініть адмінку так, щоб при перегляді моделі Page вона показується списком з колонками категорія, ім'я сторінки та url.

Натяки
......
Якщо, щоб зробити вправи, вам потрібна допомога або натхнення - сподіваємося ці підказки вам допоможуть.

* Змініть модель ``Category`` додавши поля ``view`` і ``likes`` як ``IntegerFields``.
* Змініть функцію ``add_cat`` в скрипті ``populate.py`` щоб вона приймала ``views`` і ``likes``. Після отримання Category c ви зможете оновити кількість переглядів за допомогою ``c.views``, і так само кількість лайків.
* Для зміни адмінки потрібно відредагувати ``rango/admin.py`` і створити клас ``PageAdmin`` успадкований від ``admin.ModelAdmin``. 
* В новому класі ``PageAdmin`` треба додати ``list_display = ('title', 'category', 'url')``.
* Нарешті, зареєструйте клас ``PageAdmin`` в адмінці Django. Для цього змініть рядок ``admin.site.register(Page)`` на ``admin.site.register(Page, PageAdmin)`` в файлі додатку Rango ``admin.py``.

.. _fig-admin-customised:

.. figure:: ../images/ch5-rango-admin-custom.png
	:figclass: align-center
	
	Оновлена адмінка для перегляду сторінок, зі стовпчиками для категорії і URL.

